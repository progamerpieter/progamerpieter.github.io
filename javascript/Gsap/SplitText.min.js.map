{"version":3,"file":"SplitText.min.js","sources":["../src/SplitText.js"],"sourcesContent":["/*!\n * SplitText 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2025, GreenSock. All rights reserved. Subject to the terms at https://gsap.com/standard-license.\n * @author: Jack Doyle\n */\n\nlet gsap, _fonts, _coreInitted, _initIfNecessary = () => _coreInitted || SplitText.register(window.gsap), _charSegmenter = typeof Intl !== \"undefined\" ? new Intl.Segmenter() : 0, _toArray = (r) => typeof r === \"string\" ? _toArray(document.querySelectorAll(r)) : \"length\" in r ? Array.from(r) : [r], _elements = (targets) => _toArray(targets).filter((e) => e instanceof HTMLElement), _emptyArray = [], _context = function() {\n}, _spacesRegEx = /\\s+/g, _emojiSafeRegEx = new RegExp(\"\\\\p{RI}\\\\p{RI}|\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?(\\\\u{200D}\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?)*|.\", \"gu\"), _emptyBounds = { left: 0, top: 0, width: 0, height: 0 }, _stretchToFitSpecialChars = (collection, specialCharsRegEx) => {\n  if (specialCharsRegEx) {\n    let charsFound = new Set(collection.join(\"\").match(specialCharsRegEx) || _emptyArray), i = collection.length, slots, word, char, combined;\n    if (charsFound.size) {\n      while (--i > -1) {\n        word = collection[i];\n        for (char of charsFound) {\n          if (char.startsWith(word) && char.length > word.length) {\n            slots = 0;\n            combined = word;\n            while (char.startsWith(combined += collection[i + ++slots]) && combined.length < char.length) {\n            }\n            if (slots && combined.length === char.length) {\n              collection[i] = char;\n              collection.splice(i + 1, slots);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  return collection;\n}, _disallowInline = (element) => window.getComputedStyle(element).display === \"inline\" && (element.style.display = \"inline-block\"), _insertNodeBefore = (newChild, parent, existingChild) => parent.insertBefore(typeof newChild === \"string\" ? document.createTextNode(newChild) : newChild, existingChild), _getWrapper = (type, config, collection) => {\n  let className = config[type + \"sClass\"] || \"\", { tag = \"div\", aria = \"auto\", propIndex = false } = config, display = type === \"line\" ? \"block\" : \"inline-block\", incrementClass = className.indexOf(\"++\") > -1, wrapper = (text) => {\n    let el = document.createElement(tag), i = collection.length + 1;\n    className && (el.className = className + (incrementClass ? \" \" + className + i : \"\"));\n    propIndex && el.style.setProperty(\"--\" + type, i + \"\");\n    aria !== \"none\" && el.setAttribute(\"aria-hidden\", \"true\");\n    if (tag !== \"span\") {\n      el.style.position = \"relative\";\n      el.style.display = display;\n    }\n    el.textContent = text;\n    collection.push(el);\n    return el;\n  };\n  incrementClass && (className = className.replace(\"++\", \"\"));\n  wrapper.collection = collection;\n  return wrapper;\n}, _getLineWrapper = (element, nodes, config, collection) => {\n  let lineWrapper = _getWrapper(\"line\", config, collection), textAlign = window.getComputedStyle(element).textAlign || \"left\";\n  return (startIndex, endIndex) => {\n    let newLine = lineWrapper(\"\");\n    newLine.style.textAlign = textAlign;\n    element.insertBefore(newLine, nodes[startIndex]);\n    for (; startIndex < endIndex; startIndex++) {\n      newLine.appendChild(nodes[startIndex]);\n    }\n    newLine.normalize();\n  };\n}, _splitWordsAndCharsRecursively = (element, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, isNested) => {\n  var _a;\n  let nodes = Array.from(element.childNodes), i = 0, { wordDelimiter, reduceWhiteSpace = true, prepareText } = config, elementBounds = element.getBoundingClientRect(), lastBounds = elementBounds, isPreformatted = !reduceWhiteSpace && window.getComputedStyle(element).whiteSpace.substring(0, 3) === \"pre\", ignoredPreviousSibling = 0, wordsCollection = wordWrapper.collection, wordDelimIsNotSpace, wordDelimString, wordDelimSplitter, curNode, words, curWordEl, startsWithSpace, endsWithSpace, j, bounds, curWordChars, clonedNode, curSubNode, tempSubNode, curTextContent, wordText, lastWordText, k;\n  if (typeof wordDelimiter === \"object\") {\n    wordDelimSplitter = wordDelimiter.delimiter || wordDelimiter;\n    wordDelimString = wordDelimiter.replaceWith || \"\";\n  } else {\n    wordDelimString = wordDelimiter === \"\" ? \"\" : wordDelimiter || \" \";\n  }\n  wordDelimIsNotSpace = wordDelimString !== \" \";\n  for (; i < nodes.length; i++) {\n    curNode = nodes[i];\n    if (curNode.nodeType === 3) {\n      curTextContent = curNode.textContent || \"\";\n      if (reduceWhiteSpace) {\n        curTextContent = curTextContent.replace(_spacesRegEx, \" \");\n      } else if (isPreformatted) {\n        curTextContent = curTextContent.replace(/\\n/g, wordDelimString + \"\\n\");\n      }\n      prepareText && (curTextContent = prepareText(curTextContent, element));\n      curNode.textContent = curTextContent;\n      words = wordDelimString || wordDelimSplitter ? curTextContent.split(wordDelimSplitter || wordDelimString) : curTextContent.match(charSplitRegEx) || _emptyArray;\n      lastWordText = words[words.length - 1];\n      endsWithSpace = wordDelimIsNotSpace ? lastWordText.slice(-1) === \" \" : !lastWordText;\n      lastWordText || words.pop();\n      lastBounds = elementBounds;\n      startsWithSpace = wordDelimIsNotSpace ? words[0].charAt(0) === \" \" : !words[0];\n      startsWithSpace && _insertNodeBefore(\" \", element, curNode);\n      words[0] || words.shift();\n      _stretchToFitSpecialChars(words, specialCharsRegEx);\n      deepSlice && isNested || (curNode.textContent = \"\");\n      for (j = 1; j <= words.length; j++) {\n        wordText = words[j - 1];\n        if (!reduceWhiteSpace && isPreformatted && wordText.charAt(0) === \"\\n\") {\n          (_a = curNode.previousSibling) == null ? void 0 : _a.remove();\n          _insertNodeBefore(document.createElement(\"br\"), element, curNode);\n          wordText = wordText.slice(1);\n        }\n        if (!reduceWhiteSpace && wordText === \"\") {\n          _insertNodeBefore(wordDelimString, element, curNode);\n        } else if (wordText === \" \") {\n          element.insertBefore(document.createTextNode(\" \"), curNode);\n        } else {\n          wordDelimIsNotSpace && wordText.charAt(0) === \" \" && _insertNodeBefore(\" \", element, curNode);\n          if (ignoredPreviousSibling && j === 1 && !startsWithSpace && wordsCollection.indexOf(ignoredPreviousSibling.parentNode) > -1) {\n            curWordEl = wordsCollection[wordsCollection.length - 1];\n            curWordEl.appendChild(document.createTextNode(charWrapper ? \"\" : wordText));\n          } else {\n            curWordEl = wordWrapper(charWrapper ? \"\" : wordText);\n            _insertNodeBefore(curWordEl, element, curNode);\n            ignoredPreviousSibling && j === 1 && !startsWithSpace && curWordEl.insertBefore(ignoredPreviousSibling, curWordEl.firstChild);\n          }\n          if (charWrapper) {\n            curWordChars = _charSegmenter ? _stretchToFitSpecialChars([..._charSegmenter.segment(wordText)].map((s) => s.segment), specialCharsRegEx) : wordText.match(charSplitRegEx) || _emptyArray;\n            for (k = 0; k < curWordChars.length; k++) {\n              curWordEl.appendChild(curWordChars[k] === \" \" ? document.createTextNode(\" \") : charWrapper(curWordChars[k]));\n            }\n          }\n          if (deepSlice && isNested) {\n            curTextContent = curNode.textContent = curTextContent.substring(wordText.length + 1, curTextContent.length);\n            bounds = curWordEl.getBoundingClientRect();\n            if (bounds.top > lastBounds.top && bounds.left <= lastBounds.left) {\n              clonedNode = element.cloneNode();\n              curSubNode = element.childNodes[0];\n              while (curSubNode && curSubNode !== curWordEl) {\n                tempSubNode = curSubNode;\n                curSubNode = curSubNode.nextSibling;\n                clonedNode.appendChild(tempSubNode);\n              }\n              element.parentNode.insertBefore(clonedNode, element);\n              prepForCharsOnly && _disallowInline(clonedNode);\n            }\n            lastBounds = bounds;\n          }\n          if (j < words.length || endsWithSpace) {\n            _insertNodeBefore(j >= words.length ? \" \" : wordDelimIsNotSpace && wordText.slice(-1) === \" \" ? \" \" + wordDelimString : wordDelimString, element, curNode);\n          }\n        }\n      }\n      element.removeChild(curNode);\n      ignoredPreviousSibling = 0;\n    } else if (curNode.nodeType === 1) {\n      if (ignore && ignore.indexOf(curNode) > -1) {\n        wordsCollection.indexOf(curNode.previousSibling) > -1 && wordsCollection[wordsCollection.length - 1].appendChild(curNode);\n        ignoredPreviousSibling = curNode;\n      } else {\n        _splitWordsAndCharsRecursively(curNode, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, true);\n        ignoredPreviousSibling = 0;\n      }\n      prepForCharsOnly && _disallowInline(curNode);\n    }\n  }\n};\nconst _SplitText = class _SplitText {\n  constructor(elements, config) {\n    this.isSplit = false;\n    _initIfNecessary();\n    this.elements = _elements(elements);\n    this.chars = [];\n    this.words = [];\n    this.lines = [];\n    this.masks = [];\n    this.vars = config;\n    this._split = () => this.isSplit && this.split(this.vars);\n    let orig = [], timerId, checkWidths = () => {\n      let i = orig.length, o;\n      while (i--) {\n        o = orig[i];\n        let w = o.element.offsetWidth;\n        if (w !== o.width) {\n          o.width = w;\n          this._split();\n          return;\n        }\n      }\n    };\n    this._data = { orig, obs: typeof ResizeObserver !== \"undefined\" && new ResizeObserver(() => {\n      clearTimeout(timerId);\n      timerId = setTimeout(checkWidths, 200);\n    }) };\n    _context(this);\n    this.split(config);\n  }\n  split(config) {\n    this.isSplit && this.revert();\n    this.vars = config = config || this.vars || {};\n    let { type = \"chars,words,lines\", aria = \"auto\", deepSlice = true, smartWrap, onSplit, autoSplit = false, specialChars, mask } = this.vars, splitLines = type.indexOf(\"lines\") > -1, splitCharacters = type.indexOf(\"chars\") > -1, splitWords = type.indexOf(\"words\") > -1, onlySplitCharacters = splitCharacters && !splitWords && !splitLines, specialCharsRegEx = specialChars && (\"push\" in specialChars ? new RegExp(\"(?:\" + specialChars.join(\"|\") + \")\", \"gu\") : specialChars), finalCharSplitRegEx = specialCharsRegEx ? new RegExp(specialCharsRegEx.source + \"|\" + _emojiSafeRegEx.source, \"gu\") : _emojiSafeRegEx, ignore = !!config.ignore && _elements(config.ignore), { orig, animTime, obs } = this._data, onSplitResult;\n    if (splitCharacters || splitWords || splitLines) {\n      this.elements.forEach((element, index) => {\n        orig[index] = {\n          element,\n          html: element.innerHTML,\n          ariaL: element.getAttribute(\"aria-label\"),\n          ariaH: element.getAttribute(\"aria-hidden\")\n        };\n        aria === \"auto\" ? element.setAttribute(\"aria-label\", (element.textContent || \"\").trim()) : aria === \"hidden\" && element.setAttribute(\"aria-hidden\", \"true\");\n        let chars = [], words = [], lines = [], charWrapper = splitCharacters ? _getWrapper(\"char\", config, chars) : null, wordWrapper = _getWrapper(\"word\", config, words), i, curWord, smartWrapSpan, nextSibling;\n        _splitWordsAndCharsRecursively(element, config, wordWrapper, charWrapper, onlySplitCharacters, deepSlice && (splitLines || onlySplitCharacters), ignore, finalCharSplitRegEx, specialCharsRegEx, false);\n        if (splitLines) {\n          let nodes = _toArray(element.childNodes), wrapLine = _getLineWrapper(element, nodes, config, lines), curNode, toRemove = [], lineStartIndex = 0, allBounds = nodes.map((n) => n.nodeType === 1 ? n.getBoundingClientRect() : _emptyBounds), lastBounds = _emptyBounds;\n          for (i = 0; i < nodes.length; i++) {\n            curNode = nodes[i];\n            if (curNode.nodeType === 1) {\n              if (curNode.nodeName === \"BR\") {\n                toRemove.push(curNode);\n                wrapLine(lineStartIndex, i + 1);\n                lineStartIndex = i + 1;\n                lastBounds = allBounds[lineStartIndex];\n              } else {\n                if (i && allBounds[i].top > lastBounds.top && allBounds[i].left <= lastBounds.left) {\n                  wrapLine(lineStartIndex, i);\n                  lineStartIndex = i;\n                }\n                lastBounds = allBounds[i];\n              }\n            }\n          }\n          lineStartIndex < i && wrapLine(lineStartIndex, i);\n          toRemove.forEach((el) => {\n            var _a;\n            return (_a = el.parentNode) == null ? void 0 : _a.removeChild(el);\n          });\n        }\n        if (!splitWords) {\n          for (i = 0; i < words.length; i++) {\n            curWord = words[i];\n            if (splitCharacters || !curWord.nextSibling || curWord.nextSibling.nodeType !== 3) {\n              if (smartWrap && !splitLines) {\n                smartWrapSpan = document.createElement(\"span\");\n                smartWrapSpan.style.whiteSpace = \"nowrap\";\n                while (curWord.firstChild) {\n                  smartWrapSpan.appendChild(curWord.firstChild);\n                }\n                curWord.replaceWith(smartWrapSpan);\n              } else {\n                curWord.replaceWith(...curWord.childNodes);\n              }\n            } else {\n              nextSibling = curWord.nextSibling;\n              if (nextSibling && nextSibling.nodeType === 3) {\n                nextSibling.textContent = (curWord.textContent || \"\") + (nextSibling.textContent || \"\");\n                curWord.remove();\n              }\n            }\n          }\n          words.length = 0;\n          element.normalize();\n        }\n        this.lines.push(...lines);\n        this.words.push(...words);\n        this.chars.push(...chars);\n      });\n      mask && this[mask] && this.masks.push(...this[mask].map((el) => {\n        let maskEl = el.cloneNode();\n        el.replaceWith(maskEl);\n        maskEl.appendChild(el);\n        el.className && (maskEl.className = el.className.replace(/(\\b\\w+\\b)/g, \"$1-mask\"));\n        maskEl.style.overflow = \"clip\";\n        return maskEl;\n      }));\n    }\n    this.isSplit = true;\n    _fonts && (autoSplit ? _fonts.addEventListener(\"loadingdone\", this._split) : _fonts.status === \"loading\" && console.warn(\"SplitText called before fonts loaded\"));\n    if ((onSplitResult = onSplit && onSplit(this)) && onSplitResult.totalTime) {\n      this._data.anim = animTime ? onSplitResult.totalTime(animTime) : onSplitResult;\n    }\n    splitLines && autoSplit && this.elements.forEach((element, index) => {\n      orig[index].width = element.offsetWidth;\n      obs && obs.observe(element);\n    });\n    return this;\n  }\n  revert() {\n    var _a, _b;\n    let { orig, anim, obs } = this._data;\n    obs && obs.disconnect();\n    orig.forEach(({ element, html, ariaL, ariaH }) => {\n      element.innerHTML = html;\n      ariaL ? element.setAttribute(\"aria-label\", ariaL) : element.removeAttribute(\"aria-label\");\n      ariaH ? element.setAttribute(\"aria-hidden\", ariaH) : element.removeAttribute(\"aria-hidden\");\n    });\n    this.chars.length = this.words.length = this.lines.length = orig.length = this.masks.length = 0;\n    this.isSplit = false;\n    _fonts == null ? void 0 : _fonts.removeEventListener(\"loadingdone\", this._split);\n    if (anim) {\n      this._data.animTime = anim.totalTime();\n      anim.revert();\n    }\n    (_b = (_a = this.vars).onRevert) == null ? void 0 : _b.call(_a, this);\n    return this;\n  }\n  static create(elements, config) {\n    return new _SplitText(elements, config);\n  }\n  static register(core) {\n    gsap = gsap || core || window.gsap;\n    if (gsap) {\n      _toArray = gsap.utils.toArray;\n      _context = gsap.core.context || _context;\n    }\n    if (!_coreInitted && window.innerWidth > 0) {\n      _fonts = document.fonts;\n      _coreInitted = true;\n    }\n  }\n};\n_SplitText.version = \"3.13.0\";\nlet SplitText = _SplitText;\n\nexport { SplitText, SplitText as default };\n"],"names":["_elements","targets","_toArray","filter","e","HTMLElement","_stretchToFitSpecialChars","collection","specialCharsRegEx","slots","word","char","combined","charsFound","Set","join","match","_emptyArray","i","length","size","startsWith","splice","_disallowInline","element","window","getComputedStyle","display","style","_insertNodeBefore","newChild","parent","existingChild","insertBefore","document","createTextNode","_getWrapper","type","config","wrapper","text","el","createElement","tag","className","incrementClass","propIndex","setProperty","aria","setAttribute","position","textContent","push","indexOf","replace","gsap","_fonts","_coreInitted","_charSegmenter","Intl","Segmenter","r","querySelectorAll","Array","from","_context","_spacesRegEx","_emojiSafeRegEx","RegExp","_emptyBounds","left","top","width","height","_SplitText","split","isSplit","this","revert","vars","onSplitResult","deepSlice","smartWrap","onSplit","autoSplit","specialChars","mask","splitLines","splitCharacters","splitWords","onlySplitCharacters","finalCharSplitRegEx","source","ignore","_data","orig","animTime","obs","elements","forEach","index","html","innerHTML","ariaL","getAttribute","ariaH","trim","curWord","smartWrapSpan","nextSibling","chars","words","lines","charWrapper","wordWrapper","_splitWordsAndCharsRecursively","prepForCharsOnly","charSplitRegEx","isNested","_a","wordDelimIsNotSpace","wordDelimString","wordDelimSplitter","curNode","curWordEl","startsWithSpace","endsWithSpace","j","bounds","curWordChars","clonedNode","curSubNode","tempSubNode","curTextContent","wordText","lastWordText","k","nodes","childNodes","wordDelimiter","reduceWhiteSpace","prepareText","elementBounds","getBoundingClientRect","lastBounds","isPreformatted","whiteSpace","substring","ignoredPreviousSibling","wordsCollection","delimiter","replaceWith","nodeType","slice","pop","charAt","shift","previousSibling","remove","parentNode","appendChild","firstChild","segment","map","s","cloneNode","removeChild","wrapLine","_getLineWrapper","lineWrapper","textAlign","startIndex","endIndex","newLine","normalize","toRemove","lineStartIndex","allBounds","n","nodeName","_this2","masks","maskEl","overflow","addEventListener","_split","status","console","warn","totalTime","anim","offsetWidth","observe","_b","disconnect","removeAttribute","removeEventListener","onRevert","call","create","register","core","utils","toArray","context","innerWidth","fonts","_initIfNecessary","SplitText","_this","checkWidths","o","w","timerId","ResizeObserver","clearTimeout","setTimeout","version"],"mappings":"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"}